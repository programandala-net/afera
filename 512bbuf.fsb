.( 512 B/BUF )

\ 512bbuf.fsb
\ 512-byte disk buffers for ZX Spectrum Abersoft Forth

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

  \ -----------------------------------------------------------
  \ Description

  \ The disk buffers of Abersoft Forth follow the fig-Forth
  \ model:

  \ B/BUF = 128 bytes per buffer
  \ B/SCR = 8 blocks per screen
  \ #BUFF = 8 disk buffers

  \ But, in order to use G+DOS disks as mass storage, with
  \ 512-byte sectors, this is more efficient, and doesn't
  \ increase the space used by the buffers:

  \ B/BUF = 512 bytes per buffer
  \ B/SCR = 2 block per screen
  \ #BUFF = 2 disk buffers

  \ In order to make this change, those constants have to be
  \ updated, and two words must be patched: `EMPTY-BUFFERS` and
  \ `+BUF`:

  \ The ordinary definition of fig-Forth `EMPTY-BUFFERS` is:
  \
  \ : EMPTY-BUFFERS  ( -- )
  \   FIRST LIMIT OVER - ERASE  ;

  \ But the definition implemented by Abersoft Forth is:

  \ : EMPTY-BUFFERS  ( -- )
  \   FIRST LIMIT OVER - ERASE
  \   LIMIT FIRST DO
  \     32767 I !
  \   132 +LOOP  ;

  \ The loop sets the disk block number of every buffer to
  \ 32767 (bit 16, the update bit, is set to 0).
  \
  \ The problem is the loop step, the original length of a disk
  \ buffer (132) is hardcoded, not calculated (`B/BUF 4 +`).

  \ Also the definition of `+BUF` must be patched for the same
  \ reason:

  \ : +BUF  ( a1 -- a2 f )
  \   132 DUP LIMIT = IF  DROP FIRST  THEN  DUP PREV @ -  ;

  \ -----------------------------------------------------------
  \ History

  \ 2015-05-08: Start, based on the code of the unfinished
  \ module <1024bbuf.fsb>.
  \
  \ 2015-05-09: Bug fixed. First working version.  Now trying
  \ to make it possible to automatically load other modules
  \ after this one.

-->

( XXXBUFFER )  \ XXX TMP copy of the original

HEX
: XXXBUFFER  ( n -- a )
  USE @ DUP >R
  BEGIN  
         0 0 AT [CHAR] - EMIT +BUF 1 0 AT .S
         0 0 AT [CHAR] | EMIT
  UNTIL  USE !
  R @ 0<
  IF
    R 2+
    R @ 7FFF AND 0 R/W
  THEN
  R !  R PREV !
  R> 2+  ;  DECIMAL -->

( XXXBLOCK )  \ XXX TMP copy of the original

: XXXBLOCK  ( n -- a )
  OFFSET @ + >R
  PREV @ DUP @  ( [prev] prevblock )
  R -  \ Compare to the block number saved on return stack.

  \ Ting says `DUP +` discards the left most bit, which is the
  \ update indicator. I don't understand why this is needed
  \ _after_ the comparation: the only combination whose result
  \ is zero is when both blocks are equal.

  DUP +
  IF ." XXX1" \ n <> previous block
    BEGIN  +BUF 0=  ." XXX2" 
      IF  ." XXX3"
         DROP R XXXBUFFER
         DUP R 1 R/W 2 -
       THEN  DUP @ R -  DUP + 0=
    UNTIL  DUP PREV !
  THEN  R> DROP 2+ ;  -->

( 512B )

: 512B  ( -- )

  \ XXX OLD
  \ B/BUF \ current value, 128, for later

  \ Change the constants:
  512 ' B/BUF !  2 ' B/SCR !  2 ' #BUFF !

  \ Patch `EMPTY-BUFFERS` and `+BUF`
  \ with the new value of `B/BUF`:
  B/BUF 4 + ' EMPTY-BUFFERS 26 + !
  B/BUF 4 + ' +BUF 2 + !

  \ Update `LIMIT`:
  FIRST B/BUF 4 + #BUFF * + ' LIMIT !

  \ Init the whole thing:
  EMPTY-BUFFERS  FIRST PREV !  FIRST USE !

  CR ." 2 512-byte buffers installed." CR

  \ After doing the changes, the interpreter can not return to
  \ this screen (at least without a complex hacking; maybe some
  \ day...) but a new one can be loaded:

  
  \ 5 LOAD
 
  \ XXX OLD
  \ Update the current disk block 
  \ ( n ) B/BUF SWAP / BLK @ DUP . SWAP / DUP . CR BLK !

  \ Make `512B` to forget itself:
  \ XXX It works
  \   [ LATEST ] LITERAL DUP DP ! PFA LFA @ CURRENT @ !
  \   ." I forgot myself!"

  \ RP! 
  \ LOADER
  \ EMPTY-BUFFERS INIT-DISC LOADT
  \ 2 XXXBLOCK U. QUIT
  ;

-->
( Forget the code and quit )

  \ BLK @ B/BUF 128 / / BLK !
  \ ." about to execute " 512B ." done" 

  \ XXX FIXME the loader hangs here, why?:
  \ FORGET 512B ." forgot" CR LOADER QUIT

512 B FORGET 512B ." forgot" CR RP! LOADER QUIT

  \ Unfortunately, `QUIT` is necessary (at least without a
  \ complex hacking; maybe some day...), so more modules can be
  \ automatically loaded after this one.

  \ XXX TMP
  \ QUIT

  \ XXX NEW try
  \ RP!
  \ ." hola"  FLUSH
  \
  \ XXX FIXME the loader hangs here, why?

  \  LOADER

  \ vim: filetype=abersoftforth
