.( Lower system below 0xC000 )

\ lowersys.fsb
\ Move ZX Spectrum Abersoft Forth below address 0xC000

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

  \ -----------------------------------------------------------
  \ Description

  \ Abersoft Forth is a fig-Forth system and so its memory map:

  \ Address         Returned by  Description
  \ --------------  -----------  --------------------------
  \ 0xFFFF (65535)               Top of memory
  \ 0xFF58 (65368)  `UDG`        User defined graphics
  \ 0xFBFF (64256)  `HI`         End of screens area
  \                                (RAM-disk)
  \ 0xD000 (53248)  `LO`         Start of screens area
  \                                (RAM-disk)
  \ 0xD000 (53248)  `LIMIT`      End of buffer area plus 1
  \ 0xCBE0 (52192)  `FIRST`      Start of buffer area
  \                                (lowest buffer start)
  \ 0xCBE0 (52192)  `R0 @`       Initial location (bottom)
  \                                of the return stack
  \                                (grows toward low memory)
  \ ?               `RP@`        Return stack pointer
  \ 0xCB40 (52032)  `TIB @`      Terminal input buffer
  \ 0xCB40 (52032)  `S0 @`       Initial location (bottom)
  \                                of the data stack
  \                                (grows toward low memory)
  \ ?               `SP@`        Data stack pointer
  \ ...                          Free space
  \ 0x819D (33181)  `PAD`        Text output buffer
  \ 0x8159 (33113)  `HERE`       `WORD` buffer
  \ 0x8159 (33113)  `HERE`       Dictionary pointer
  \ 0x5E40 (24128)  `0 +ORIGIN`  Start of the system


  \ The problem is the ZX Spectrum 128 models page the
  \ additional RAM banks on the upper 16 KiB of the memory
  \ (0xC000-0xFFFF).  In order to use this extra memory, the
  \ vital parts of the Forth system (the data stack, the
  \ terminal input buffer, the return stack and the disk block
  \ buffers) have to be moved below address 0xC000.

  \ -----------------------------------------------------------
  \ History of this file

  \ 2015-05-06: Start.
  \ 2015-05-07: Data stack, return stack and TIB are moved.
  \ 2015-05-08: Block buffers are moved. `FREE` is patched.

  \ -----------------------------------------------------------

-->

( Move the data stack )

  \ Definition of `?STACK` in C. H. Ting's book _Systems Guide
  \ to figFORTH_:

  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ >        \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;

  \ Definition of `?STACK` in Abersoft Forth:

  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ SWAP U<  \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;

  \ The lower bound has to be changed: instead of `HERE 128 +`
  \ it must be the new fixed address.
  \
  \ The new code is shorter (4 bytes instead of 8): For the
  \ sake of execution speed, the rest of the original code, `<
  \ 7 ?ERROR ;`, will be moved, instead of filling the gap with
  \ `NOOP`.
  \
  \ Beside, the first `?ERROR` has to be temporary deactivated
  \ until the new stack is ready, otherwise an error will
  \ happen; this is done by overwritting it with `2DROP`.

HEX  HERE

  \ The current dictionary pointer is both the start of the
  \ patch and the new lower bound of the data stack.

  \ Step 0: Compile the patch for `?STACK`
  \
  \ The first `?ERROR` in `?STACK` is temporarily substituted
  \ with `2DROP` to prevent a later error during the init of
  \ the new data stack pointers.

' 2DROP CFA , ' SP@ CFA , ' LIT CFA , DUP ,
' < CFA , ' LIT CFA , 7 , ' ?ERROR CFA , ' ;S CFA ,

  \ Step 1: Copy the patch

DUP             \ origin: start of the compiled patch
' ?STACK 0C +   \ destination: first `?ERROR` in `?STACK`
OVER HERE SWAP - CMOVE  \ do it

  \ Step 2: Allocate space for the new data stack
  \ (0x80 bytes minus the bytes reused from the patch)

80 HERE ROT - - ALLOT

  \ Step 3: Init the new data stack pointers

  \ System addresses:
  \   0x5E06 holds `S0`
  \   0x5E54 holds its initial value

HERE DUP 5E06 ! 5E52 ! SP!

  \ Step 4: Restore the first `?ERROR` of `?STACK`,
  \ that was substituted by a `2DROP`

  ' ?ERROR CFA ' ?STACK 0C + !

DECIMAL

-->

( Move the terminal input buffer )

HEX

  \ System addresses:
  \   0x5E0A holds the address of `TIB`
  \   0x5E56 holds its initial value

HERE DUP 5E0A ! 5E56 !  52 ALLOT

DECIMAL

-->

( Move the return stack )

HEX  80 ALLOT \ space for the new return stack

  \ System addresses:
  \   0x5E08 holds `R0`
  \   0x5E54 holds its initial value

  \ 0x5E54 is used only by `COLD`, so it's safe to change it
  \ now; it will be used to update 0x5E08:
HERE 5E54 !

: TASK ;

: RDEPTH  ( -- u )  RP@ R0 @ - -2 /  ;

0 VARIABLE SAVED  \ elements saved from the old return stack

: >R<  ( -- )

  \ Exchange the return stacks.

  \ Copy the contents of the old return stack
  \ to the data stack
  \ (the `LOOP` parameters must be preserved):
  RDEPTH DUP SAVED !
  0 DO  R> R> R> ROT ROT >R >R  LOOP

  \ Activate the new return stack:
  5E54 @ 5E08 !  RP!

  \ Restore the contents of the old return stack
  \ from the data stack to the new return stack
  \ (the `LOOP` parameters must be preserved):
  SAVED @ 0 DO  R> R> ROT >R >R >R  LOOP  ;

>R<  FORGET TASK  \ do it and forget the code

DECIMAL -->

( Move the disk block buffers and update FREE )

HERE  \ address of the new buffers
DUP FIRST -  \ negative offset from the old buffers

LIMIT FIRST -  ALLOT \ space for the new buffers

: >BUF<  ( -n a -- )

  \ Move the disk buffers to their new position.

  \ a = address of the new buffers
  \ -n = offset from the old buffers to the new ones
  
  \ Copy the disk buffers to the new address:
  FIRST OVER LIMIT FIRST - CMOVE

  \ Update their bound addresses:
  ( a ) DUP ' FIRST !
            B/BUF 4 + #BUFF * + ' LIMIT !

  \ Update the buffer pointers with the offset:
  ( -n ) DUP PREV +! USE +!  ;

SWAP >BUF<  FORGET >BUF<  \ do it and forget the code

  \ The word `FREE` returns the free dictionary space,
  \ according to the original memory map:
  \
  \   : FREE  ( -- n )  SP@ HERE -  ;
  \
  \ It has to be modified because the top limit of the free
  \ dictionary space is not the stack pointer any more, but the
  \ start of the RAM-disk, returned by `LO`:

  ' LO CFA ' FREE !

  \ vim: filetype=abersoftforth
