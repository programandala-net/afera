\ gdos_2.fsb
\ GDOS support for ZX Spectrum Abersoft Forth (part 2)

\ Copyright (C) 1988,1994,2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

\ Requirements:
\ XXX todo
\ fsb:
\   (http://programandala.net/en.program.fsb.html)
\ Afera's main file
\   (http://programandala.net/en.program.afera.html)
\ Pleonasmo AF
\   (http://programandala.net/en.program.pleonasmo.html)

  \ -----------------------------------------------------------
  \ History of this file

  \ 2015-04-15: Extracted from <gdos_1.fsb>.

  \ -----------------------------------------------------------
  \ Todo

  \ XXX FIXME still not working fine: it seems some control
  \ chars are included in filenames.

.( GDOS extensions -- part 2)

2 10 THRU

( Save a file)

CODE (MEM>DISK)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  BC PUSH  IX PUSH  \ save the Forth registers
  DSTR1 IX LDP#
  HOFLE HOOK \ open the file and create its header
  NC IF \ no error?
    HD0D DE LDP \ start
    HD0B BC LDP \ length
    HSVBK HOOK \ save to file
    NC IF  \ no error?
      CFSM HOOK  \ close the file
    THEN
  THEN  IX POP  BC POP  \ restore the Forth registers
  AF PUSH  \ ior
  END-CODE

( Load a file)

CODE (DISK>MEM)  ( -- ior )

  \ Load a file from disk using the data hold in UFIA.

  BC PUSH  IX PUSH  \ save the Forth registers
  DSTR1 IX LDP#  HGFLE HOOK \ get the file
  NC IF \ no error?  -- load the file header:
    HD00 DE LDP#  9 B LD# \ destination and count
    BEGIN
      LBYT HOOK \ load byte and store it in A
      DE STAP  DE INCP  \ update destination and count
    DSZ
    HD0D DE LDP  HD0B BC LDP \ start and length
    HLDBK HOOK \ load the file
  THEN  IX POP  BC POP  \ restore the Forth registers
  AF PUSH  \ ior
  END-CODE

( Delete a file)

CODE (DELETE-FILE)  ( -- ior )

  \ Delete a disk file using the data hold in UFIA.

  BC PUSH  IX PUSH  \ save the Forth registers
  UFIA IX LDP#
  HERAZ HOOK \ erase the file
  IX POP  BC POP  \ restore the Forth registers
  AF PUSH

  END-CODE

( CAT )

CODE (CAT)  ( -- )
  \ XXX FIXME -- CAT is not finished yet
  BC PUSH  IX PUSH  \ save the Forth registers
  PCAT HOOK
  IX POP  BC POP  \ restore the Forth registers
  END-CODE

: CAT  ( -- )  -SCREEN (CAT) +SCREEN  ;

( User interface: Forth RAM-disc )

FORTH DEFINITIONS

: SAVED?  ( ca len -- f n )
  \ Save the Forth RAM-disc to disk
  \ (word named after Abersoft Forth's `SAVET`).
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  RAM-DISC>UFIA (MEM>DISK) IOR>ERROR  ;

: SAVED  ( ca len -- )
  \ Save the Forth RAM-disc to disk
  \ (word named after Abersoft Forth's `SAVET`).
  \ ca len = filename
  SAVED? ?ERROR  ;

: LOADD?  ( ca len -- f n )
  \ Load a Forth RAM-disc from disk.
  \ (word named after Abersoft Forth's `LOADT`).
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  RAM-DISC>UFIA (DISK>MEM) IOR>ERROR  ;

: LOADD  ( ca len -- )
  \ Load a Forth RAM-disc from disk.
  \ (word named after Abersoft Forth's `LOADT`).
  \ ca len = filename
  LOADD? ?ERROR  ;

: RUND  ( ca len -- )

  \ XXX OLD

  \ Read a new RAM-disc from disk and load its first block.
  
  \ ca len = filename

  \ `DEPTH` is checked to prevent a RAM disk from leaving
  \ something on the stack, and also to make it possible to
  \ load individual files of the library, when the ZX Spectrum
  \ emulator automatically rewinds the tape file (like Fuse),
  \ what causes the same file to be loaded in an endless loop.
  \
  \ `RP!` is neded before `LOAD` because every `LOAD` saves the
  \ contents of `BLK` `IN` into the return stack, beside its
  \ own return address; chained loading of several RAM disks
  \ would fill it.
  \
  \ `QUIT` is needed at the end because otherwise the `LOAD`
  \ that loaded the block of `RUND` would continue to interpret
  \ after `RUND`, but the contents of the block would had
  \ already been changed.

  DEPTH IF  BLK @ IF  ." Stack not empty " 20 ERROR  THEN  THEN
  FLUSH INIT-DISC LOADD RP! 1 LOAD  ." ok" QUIT  ;

( User interface: blocks of the Forth RAM-disc )


: (/LOADD)  ( n ca len -- a len1 ca2 len2 )
  \ Prepare the parameters to load a RAM-disc from disk,
  \ at address of block n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first block (0..10)
  ROT FLUSH BLOCK>A 0 2SWAP ;

: /LOADD  ( n ca len -- )
  \ Load a RAM-disc from disk, at address of block n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first block (0..10)
  (/LOADD) DISK>MEM  ;

: /LOADD?  ( n ca len -- error? error )
  \ Load a RAM-disc from disk, at address of block n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first block (0..10)
  (/LOADD) DISK>MEM?  ;

: (/SAVED)  ( n1 n2 ca len -- a1 len1 ca2 len2 )
  \ Prepare the parameters to save a RAM-disc to disk,
  \ from block n1 to block n2.
  \ n1 = first block (0..10)
  \ n2 = last block (0..10)
  \ ca len = filename
  2SWAP FLUSH 1+ BLOCK>A SWAP BLOCK>A DUP ROT SWAP - 2SWAP  ;

: /SAVED  ( n1 n2 ca len -- )
  \ Save a RAM-disc to disk, from block n1 to block n2.
  \ n1 = first block (0..10)
  \ n2 = last block (0..10)
  \ ca len = filename
  (/SAVED) MEM>DISK  ;

: /SAVED?  ( n1 n2 ca len -- error? error )
  \ Save a RAM-disc to disk, from block n1 to block n2.
  \ n1 = first block (0..10)
  \ n2 = last block (0..10)
  \ ca len = filename
  (/SAVED) MEM>DISK?  ;

( User interface: ordinary files )

: DISK>MEM?  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >UFIA (DISK>MEM) IOR>ERROR  ;

: DISK>MEM  ( a1 len1 ca2 len2 -- )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  DISK>MEM? ?ERROR  ;

: MEM>DISK?  ( ca1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >UFIA (MEM>DISK) IOR>ERROR  ;

: MEM>DISK  ( ca1 len1 ca2 len2 -- )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  MEM>DISK? ?ERROR  ;

: DELETE-FILE?  ( ca len -- f n )
  \ Delete a disk file.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2SWAP >UFIA (DELETE-FILE) IOR>ERROR  ;

: DELETE-FILE  ( ca len -- )
  \ Delete a disk file.
  \ ca len = filename
  DELETE-FILE? ?ERROR  ;

  \ vim: filetype=abersoftforth

