\ gplusdos_2.fsb
\ G+DOS support for ZX Spectrum Abersoft Forth (part 2)

\ Copyright (C) 1988,1994,2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

  \ -----------------------------------------------------------
  \ Note

  \ "DISC" means the Forth RAM disk, after the name used by
  \ Abersoft Forth's documentation and vocabulary, e.g.
  \ `INIT-DISC`.
  \
  \ "DISK" means a G+DOS disk.

  \ -----------------------------------------------------------
  \ History of this file

  \ 2015-04-15: Extracted from <gdos_1.fsb>.
  \
  \ 2015-04-16: File renamed to <g+dos_2.fsb>.
  \
  \ 2015-04-30: New version of `RUND` and new word `/RUND`,
  \ after the tape versions `RUNT` and `/RUNT`. `'BLOCK`
  \ instead of `BLOCK>A`, after the change in the main file of
  \ the library.
  \
  \ 2015-05-03: Simpler word names: no "MEM" affix.
  \
  \ 2015-05-08: Renamed to <gplusdos_2.fsb>, because of an
  \ issue with Makefile. Some words are renamed.
  \
  \ 2015-05-10: `'BLOCK` changed to `'SCR`, after the changes
  \ in the library.
  \
  \ 2015-05-12: The "RAM-" prefix is removed from the RAM disk
  \ words, after the changes in the library.

  \ -----------------------------------------------------------
  \ Todo

  \ XXX FIXME still not working fine: it seems some control
  \ chars are included in filenames.

-->

.( G+DOS support -- part 2)

3 11 THRU

( Save a file)

CODE (>DISK)  ( -- ior )

  \ Save a file to disk using the data hold in UFIA.

  BC PUSH  IX PUSH  \ save the Forth registers
  UFIA IX LDP#
  HOFLE HOOK \ open the file and create its header
  NC IF \ no error?
    HD0D DE LDP \ start
    HD0B BC LDP \ length
    HSVBK HOOK \ save to file
    NC IF  \ no error?
      CFSM HOOK  \ close the file
    THEN
  THEN  IX POP  BC POP  \ restore the Forth registers
  AF PUSH  \ ior
  NEXT JP
  END-CODE

( Load a file)

  \ XXX FIXME Sometimes it fails.

  \ There's no difference between the assembler and the opcode
  \ versions. The code is the same.
  \
  \ 2015-05-10: it works.
  \
  \ 2015-05-12: 
  \
  \ Test done: 16384 0 S" UPPERC" <DISK
  \ Test done: 16384 2048 S" UPPERC" <DISK
  \
  \ It fails: the border flashes, but nothing is loaded 
  \ on the screen, and then the system hangs.
  \ It seems a neverending loop in entered in `(FIND)`.
  \ 

  \ CREATE (<DISK)  ( -- ior )  HEX

  \   \ Load a file from disk using the data hold in UFIA.

  \   C5 C,               \ push bc
  \   DD C, E5 C,         \ push ix
  \   DD C, 21 C, UFIA ,  \ ld ix,ufia
  \   CF C, HGFLE C,      \ hook hgfle
  \   38 C, 15 C,         \ jr c,end
  \   11 C, HD00 ,        \ ld de,hd00
  \   06 C, 09 C,         \ ld b,09
  \                       \ do:
  \   CF C, LBYT C,       \ hook lbyt
  \   12 C,               \ ld (de),a
  \   13 C,               \ inc de
  \   10 C, FA C,         \ djnz do
 \ ( Load a file --2 )
  \   ED C, 5B C, HD0D ,  \ ld de,(hd0d)
  \   ED C, 4B C, HD0B ,  \ ld bc,(hd0b)
  \   CF C, HLDBK C,      \ hook hldbk
  \                       \ end:
  \   DD C, E1 C,         \ pop ix
  \   C1 C,               \ pop bc
  \   F5 C,               \ push af
  \   C3 C, NEXT ,        \ jp next
  \   SMUDGE DECIMAL


  CODE (<DISK)  ( -- ior )
    BC PUSH  IX PUSH  \ save the Forth registers
    UFIA IX LDP#  HGFLE HOOK \ get the file
    NC IF \ no error?  -- load the file header:

      \ Load the file header
      HD00 DE LDP#  9 B LD# \ destination and count
      BEGIN
        LBYT HOOK \ load byte and store it in A
        \ XXX FIXME
        \ The problem is the file header 
        \ overwrites the data set in UFIA.

        \ XXX TMP commented out
        \ DE STAP  DE INCP  \ update destination and count
      DSZ

      \ Load the file data
      HD0D DE LDP  HD0B BC LDP \ start and length
      HLDBK HOOK \ load the file

    THEN  IX POP  BC POP  \ restore the Forth registers
    AF PUSH  \ ior
    NEXT JP
  END-CODE

( Delete a file)

CODE (-DISK)  ( -- ior )

  \ Delete a disk file using the data hold in UFIA.

  BC PUSH  IX PUSH  \ save the Forth registers
  UFIA IX LDP#
  HERAZ HOOK \ erase the file
  IX POP  BC POP  \ restore the Forth registers
  AF PUSH
  NEXT JP
  END-CODE

( CAT )

CODE (CAT)  ( -- )
  \ XXX FIXME -- it prints garbage and makes the system
  \ unusable
  BC PUSH  IX PUSH  \ save the Forth registers
  PCAT HOOK
  IX POP  BC POP  \ restore the Forth registers
  NEXT JP
  END-CODE

: CAT  ( -- )  -SCREEN (CAT) +SCREEN  ;

( User interface: Forth RAM-disc )

: DISC>UFIA  ( ca len f -- )
  \ Init the User File Information Area
  \ to load or save the Forth RAM-disc.
  \ ca1 len1 = filename
  LO /DISC 2SWAP >UFIA  ;

: SAVED?  ( ca len -- f n )
  \ Save the Forth RAM-disc to disk
  \ (word named after Abersoft Forth's `SAVET`).
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  DISC>UFIA (>DISK) IOR>ERROR  ;

: SAVED  ( ca len -- )
  \ Save the Forth RAM-disc to disk
  \ (word named after Abersoft Forth's `SAVET`).
  \ ca len = filename
  SAVED? ?ERROR  ;

: LOADD?  ( ca len -- f n )
  \ Load a Forth RAM-disc from disk.
  \ (word named after Abersoft Forth's `LOADT`).
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  DISC>UFIA (<DISK) IOR>ERROR  ;

: LOADD  ( ca len -- )
  \ Load a Forth RAM-disc from disk.
  \ (word named after Abersoft Forth's `LOADT`).
  \ ca len = filename
  LOADD? ?ERROR  ;

: /RUND  ( ca len n -- )
  \ Read a new RAM-disc from disk and load block 'n'.
  \ ca len = filename
  FLUSH INIT-DISC LOADD LOAD  ;
 
: RUND  ( ca len -- )
  \ Read a new RAM-disc from disk and load its first block.
  \ ca len = filename
  1 /RUND ;

( User interface: ordinary files )

: <DISK?  ( a1 len1 ca2 len2 -- f n )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >UFIA (<DISK) IOR>ERROR  ;

: <DISK  ( a1 len1 ca2 len2 -- )
  \ Load a file from disk.
  \ a1 len1   = memory region to load
  \ ca2 len2  = filename
  <DISK? ?ERROR  ;

: >DISK?  ( ca1 len1 ca2 len2 -- f n )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  \ f         = error?
  \ n         = error
  >UFIA (>DISK) IOR>ERROR  ;

: >DISK  ( ca1 len1 ca2 len2 -- )
  \ Save a file to disk.
  \ a1 len1   = memory region to save
  \ ca2 len2  = filename
  >DISK? ?ERROR  ;

: -DISK?  ( ca len -- f n )
  \ Delete a disk file.
  \ ca len  = filename
  \ f       = error?
  \ n       = error
  0 0 2SWAP >UFIA (-DISK) IOR>ERROR  ;

: -DISK  ( ca len -- )
  \ Delete a disk file.
  \ ca len = filename
  -DISK? ?ERROR  ;

( User interface: blocks of the Forth RAM-disc )

: (/LOADD)  ( n ca len -- a len1 ca2 len2 )
  \ Prepare the parameters to load a RAM-disc from disk,
  \ at address of screen n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first block (1..11)
  ROT FLUSH 'SCR 0 2SWAP ;

: /LOADD  ( n ca len -- )
  \ Load a RAM-disc from disk, at address of screen n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first screen (1..11)
  (/LOADD) <DISK  ;

: /LOADD?  ( n ca len -- error? error )
  \ Load a RAM-disc from disk, at address of screen n.
  \ Warning: the file will be loaded, no matter its length.
  \ n = first screen (1..11)
  (/LOADD) <DISK?  ;

: (/SAVED)  ( n1 n2 ca len -- ca len ca2 len2 )
  \ Prepare the parameters to save a RAM-disc to disk,
  \ from screen n1 to screen n2.
  \ n1 = first screen (1..11)
  \ n2 = last screen (1..11)
  \ ca len = filename
  \ ca2 len2 = memory zone
  FLUSH 2SWAP 1+ 'SCR SWAP 'SCR DUP ROT SWAP - 2SWAP  ;

: /SAVED  ( n1 n2 ca len -- )
  \ Save a RAM-disc to disk, from block n1 to block n2.
  \ n1 = first block (1..11)
  \ n2 = last block (1..11)
  \ ca len = filename
  (/SAVED) >DISK  ;

: /SAVED?  ( n1 n2 ca len -- error? error )
  \ Save a RAM-disc to disk, from block n1 to block n2.
  \ n1 = first block (1..11)
  \ n2 = last block (1..11)
  \ ca len = filename
  (/SAVED) >DISK?  ;


  \ vim: filetype=abersoftforth

