\ lowermem.fsb
\ Move ZX Spectrum Abersoft Forth below address 0xC000

\ Copyright (C) 1985-1987,2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html


  \ -----------------------------------------------------------
  \ Description

  \ Abersoft Forth is a fig-Forth system and so is its
  \ memory map:

  \ Address         Returned by  Description
  \ --------------  -----------  -------------------------- 
  \ 0xFFFF (65535)               Top of memory
  \ 0xFF58 (65368)  `UDG`        User defined graphics
  \ 0xFBFF (64256)  `HI`         End of screens area
  \                                (RAM-disc)
  \ 0xD000 (53248)  `LO`         Start of screens area
  \                                (RAM-disc)
  \ 0xD000 (53248)  `LIMIT`      End of buffer area plus 1
  \ 0xCBE0 (52192)  `FIRST`      Start of buffer area
  \                                (lowest buffer start)
  \ 0xCBE0 (52192)  `R0 @`       Initial location (bottom)
  \                                of the return stack
  \                                (grows toward low memory)
  \ ?               `RP@`        Return stack pointer
  \ 0xCB40 (52032)  `TIB @`      Terminal input buffer
  \ 0xCB40 (52032)  `S0 @`       Initial location (bottom)
  \                                of the data stack
  \                                (grows toward low memory)
  \ ?               `SP@`        Data stack pointer
  \ ...                          Free space
  \ 0x819D (33181)  `PAD`        Text output buffer
  \ 0x8159 (33113)  `HERE`       Dictionary pointer
  \ 0x5E40 (24128)  `0 +ORIGIN`  Start of the system


  \ The problem is ZX Spectrum 128 models page the additional
  \ RAM banks on the upper 16 KiB of the memory.  In order to
  \ use this extra memory, some parts of the Forth system have
  \ to be moved below address 0xC000.

  \ -----------------------------------------------------------
  \ History of this file

  \ 2015-05-06: Start.
  
  \ -----------------------------------------------------------

-->

( Lower data stack -- Method 1 )


  \ Definition of `?STACK` in _Systems Guide to figFORTH_:

  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ >        \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;
  
  \ Definition of `?STACK` in Abersoft Forth:
 
  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ SWAP U<  \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;

  \ The lower bound has to be changed: instead of `HERE 128 +`
  \ it must be the new fixed address.
  \
  \ The new code is shorter (4 bytes instead of 8): For the
  \ sake of execution speed, the rest of the original code, `<
  \ 7 ?ERROR ;` will be moved, instead of filling the gap with
  \ `NOOP`.
  \
  \ Beside, the first `?ERROR` has to be temporary deactivated
  \ until the new stack is ready; this is done by overwritting
  \ it with `2DROP`.

HEX  HERE  ( a )

  \ The current dictionary pointer is both the start of the
  \ patch and the new lower bound of the data stack.

  \ Compile the patch for `?STACK`
  \
  \ The first `?ERROR` in `?STACK` is temporarily substited
  \ with `2DROP` to prevent an error to be issued later during
  \ the init of the new data stack pointers.

' 2DROP CFA , ' SP@ CFA , ' LIT CFA , DUP ,
' < CFA , ' LIT CFA , 7 , ' ?ERROR CFA , ' ;S CFA ,

  \ Copy the patch

DUP   \ origin: start of the compiled patch
6C39  \ destination: address of first `?ERROR` in `?STACK`
OVER HERE SWAP - CMOVE  \ do it

  \ Allocate space for the new data stack

80 HERE ROT - - ALLOT  \ 80 minus the bytes used by the patch

  \ Init the new data stack pointers

  \ 5E06 holds S0
  \ 5E54 holds its initial value

HERE DUP 5E06 ! 5E52 ! SP!

  \ Restore the first `?ERROR` of `?STACK`,
  \ that was substituted by a `2DROP`

  ' ?ERROR CFA ' ?STACK 0C + !

DECIMAL

-->

( Lower return stack -- Method 1 )


HEX

80 ALLOT \ space for the new return stack

  \ Init the new return stack pointers

  \ 5E08 holds R0
  \ 5E54 holds its initial value

HERE 5E54 !

  \ RP!  \ XXX FIXME crash!
  \ XXX how to change the RP safely, beside `QUIT`?

  \ QUIT

  \ : >R<  ( -- )
  \   \ XXX works!
  \   RDEPTH . KEY DROP
  \   R> R> R> R> R> R> R> R> R> R> R> R>
  \   5E54 @ 5E08 !  RP!
  \   >R >R >R >R >R >R >R >R >R >R >R >R
  \   ;
: TASK ; 0 VARIABLE SAVED
: RDEPTH  ( -- u )  RP@ R0 @ - -2 /  ;


  : >R<  ( -- )
    \ XXX works!
    RDEPTH DUP SAVED !
    ." Save " DUP . ." elements..." CR KEY DROP
    0 DO  I . R> R> R> ROT ROT >R >R  LOOP CR
    ." Set stack..." CR KEY DROP
    5E54 @ 5E08 !  RP!
    ." And restore the elements..." CR KEY DROP
    SAVED @ 0 DO  I . R> R> ROT >R >R >R  LOOP CR KEY DROP
    ;

>R< FORGET TASK  DECIMAL

  \ 5E68 =
  \ 24168 CONSTANT RP  \ address of the return stack pointer

  \ vim: filetype=abersoftforth
