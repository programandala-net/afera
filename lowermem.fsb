.( lowermem )

\ lowermem.fsb
\ Move ZX Spectrum Abersoft Forth below address 0xC000

\ Copyright (C) 1985-1987,2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html


  \ -----------------------------------------------------------
  \ Description

  \ Abersoft Forth is a fig-Forth system and so its memory map:

  \ Address         Returned by  Description
  \ --------------  -----------  -------------------------- 
  \ 0xFFFF (65535)               Top of memory
  \ 0xFF58 (65368)  `UDG`        User defined graphics
  \ 0xFBFF (64256)  `HI`         End of screens area
  \                                (RAM-disc)
  \ 0xD000 (53248)  `LO`         Start of screens area
  \                                (RAM-disc)
  \ 0xD000 (53248)  `LIMIT`      End of buffer area plus 1
  \ 0xCBE0 (52192)  `FIRST`      Start of buffer area
  \                                (lowest buffer start)
  \ 0xCBE0 (52192)  `R0 @`       Initial location (bottom)
  \                                of the return stack
  \                                (grows toward low memory)
  \ ?               `RP@`        Return stack pointer
  \ 0xCB40 (52032)  `TIB @`      Terminal input buffer
  \ 0xCB40 (52032)  `S0 @`       Initial location (bottom)
  \                                of the data stack
  \                                (grows toward low memory)
  \ ?               `SP@`        Data stack pointer
  \ ...                          Free space
  \ 0x819D (33181)  `PAD`        Text output buffer
  \ 0x8159 (33113)  `HERE`       `WORD` buffer
  \ 0x8159 (33113)  `HERE`       Dictionary pointer
  \ 0x5E40 (24128)  `0 +ORIGIN`  Start of the system


  \ The problem is the ZX Spectrum 128 models page the
  \ additional RAM banks on the upper 16 KiB of the memory
  \ (0xC000-0xFFFF).  In order to use this extra memory, the
  \ vital parts of the Forth system (the data stack, the
  \ terminal input buffer, the return stack and the disk block
  \ buffers) have to be moved below address 0xC000.

  \ -----------------------------------------------------------
  \ History of this file

  \ 2015-05-06: Start.
  \ 2015-05-07: Data stack, Return stack and TIB completed.
  
  \ -----------------------------------------------------------

-->

( Lower the data stack )


  \ Definition of `?STACK` in C. H. Ting's book _Systems Guide
  \ to figFORTH_:

  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ >        \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;
  
  \ Definition of `?STACK` in Abersoft Forth:
 
  \ : ?STACK  ( -- )
  \   \ Issue error message
  \   \ if the data stack is out of bounds.
  \   SP@ S0 @ SWAP U<  \ out of upper bound?
  \   1 ?ERROR          \ stack underflow
  \   SP@ HERE 128 + <  \ out of lower bound?
  \   7 ?ERROR          \ stack overflow
  \   ;

  \ The lower bound has to be changed: instead of `HERE 128 +`
  \ it must be the new fixed address.
  \
  \ The new code is shorter (4 bytes instead of 8): For the
  \ sake of execution speed, the rest of the original code, `<
  \ 7 ?ERROR ;` will be moved, instead of filling the gap with
  \ `NOOP`.
  \
  \ Beside, the first `?ERROR` has to be temporary deactivated
  \ until the new stack is ready, otherwise an error will
  \ happen; this is done by overwritting it with `2DROP`.

HEX  HERE  ( a )

  \ The current dictionary pointer is both the start of the
  \ patch and the new lower bound of the data stack.

  \ Step 0: Compile the patch for `?STACK`
  \
  \ The first `?ERROR` in `?STACK` is temporarily substited
  \ with `2DROP` to prevent an error to be issued later during
  \ the init of the new data stack pointers.

' 2DROP CFA , ' SP@ CFA , ' LIT CFA , DUP ,
' < CFA , ' LIT CFA , 7 , ' ?ERROR CFA , ' ;S CFA ,

  \ Step 1: Copy the patch

DUP   \ origin: start of the compiled patch
6C39  \ destination: address of first `?ERROR` in `?STACK`
OVER HERE SWAP - CMOVE  \ do it

  \ Step 2: Allocate space for the new data stack
  \ (80 bytes minus the bytes reused from the patch)

80 HERE ROT - - ALLOT

  \ Step 3: Init the new data stack pointers

  \ 5E06 holds S0
  \ 5E54 holds its initial value

HERE DUP 5E06 ! 5E52 ! SP!

  \ Step 4: Restore the first `?ERROR` of `?STACK`,
  \ that was substituted by a `2DROP`

  ' ?ERROR CFA ' ?STACK 0C + !

DECIMAL

-->

( Lower the terminal input buffer )

  \ 5E0A holds the address of TIB
  \ 5E56 holds its initial value

HEX

HERE DUP 5E0A ! 5E56 !
52 ALLOT

DECIMAL

-->

( Lower the return stack )

HEX  80 ALLOT \ space for the new return stack

  \ 5E08 holds R0
  \ 5E54 holds its initial value

HERE 5E54 !  \ used only by `COLD`; it's safe to change it now

: TASK ;
: RDEPTH  ( -- u )  RP@ R0 @ - -2 /  ;
0 VARIABLE SAVED  \ elements saved from the old return stack
: >R<  ( -- )
  \ Init the new return stack,
  \ copying the contents of the old one,
  \ and start using it.
  RDEPTH DUP SAVED !
  0 DO  R> R> R> ROT ROT >R >R  LOOP
  5E54 @ 5E08 !  RP!
  SAVED @ 0 DO  R> R> ROT >R >R >R  LOOP  ;

>R<  FORGET TASK  \ do it and forget the code

DECIMAL 

( Lower the disk block buffers and update FREE )

  \ XXX FIXME the buffers causes problems
  \ XXX something missing?

HERE  \ address of the new buffers
DUP FIRST -  \ negative offset from the old buffers

  \ Important:
  \
  \ The fig-Forth model describes `LIMIT` as:
  \
  \ "the address just above the highest memory available for a
  \ disc buffer. Usually this is the highest system memory."
  \ (Forth Interest Group, Release 1 of fig-FORTH, 1979-05;
  \ OCR-ed by Albert van der Horst DFW The Netherlands 2000-03)
  \ 
  \ Or:
  \
  \ "Address of the last byte of disk buffers plus one,
  \ pointing to the free memory not used by the Forth system."
  \ (C. H. Ting, "Systems Guide to figFORTH", second edition,
  \ 1989-05)
  \
  \ The definition in the Abersoft Forth manual is simply plain
  \ wrong:
  \
  \ "A constant leaving the address just above the highest
  \ memory address used by the system."
  \
  \ XXX FIXME -- I'm wrong:
  \ Actually, `LIMIT` returns the address of the tail cell of
  \ the last disk buffer; and all disk buffer tails must
  \ contain 0.
  \ Somehow this cell is not erased by `EMPTY-BUFFERS`
  \ (probably because it's supposed to be harcoded during the
  \ building of the system) so in order to make sure it's zero,
  \ it's not calculated in the space allocated by `ALLOT`, but
  \ compiled after it:

LIMIT FIRST -  ALLOT 0 ,  \ space for the new buffers

  \ XXX Done with a word, to prevent the code to spread on two
  \ disk blocks, but tt makes no difference:

: TASK ;
: >BUF<  ( -n a -- )
  \ a = address of the new buffers
  \ -n = offset from the old buffers to the new ones
  FIRST OVER LIMIT FIRST - CMOVE  \ copy the old buffers
  ' FIRST !  HERE ' LIMIT !  \ update the constants
  DUP PREV @ +! USE +!  \ update the variables with the offset
  ;
SWAP >BUF<  FORGET TASK  \ do it and forget the code

  \ The word `FREE` returns the free dictionary space,
  \ according to the original memory map:
  \
  \   : FREE  ( -- n )  SP@ HERE -  ;
  \
  \ It has to be modified because the top limit of the free
  \ dictionary space is not the stack pointer any more, but the
  \ start of the RAM disk, returned by `LO`:

' LO CFA ' FREE !


  \ vim: filetype=abersoftforth
