.( Strings )

\ strings.fsb
\ Strings extensions for ZX Spectrum Abersoft Forth

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

  \ -----------------------------------------------------------
  \ Requirements

  \ extend.fsb
  \ flags.fsb

  \ -----------------------------------------------------------
  \ History of this file
  
  \ 2015-03:
  \
  \ `CHAR`, `[CHAR]`, `PARSE-TEXT`, `PARSE-NAME`, `SLIT`, `S,`,
  \ `SLITERAL`, `.(`, `(S)`, `S"`, `S'`.
  \
  \ 2015-03-28: File created with code extracted from the main
  \ file of the library. New: `STR=`, after Gforth.
  \
  \ 2015-03-29: New: 'PLACE' and '+PLACE', after Gforth;
  \ circular string buffer and related tools, adapted from csb8
  \ (http://programandala.net/en.program.csb8.html).
  \
  \ 2015-03-30:
  \
  \ `.(`is moved to the main extend module, in order to use it
  \ at block headers.
  \
  \ 2015-03-31:
  \
  \ New: `/STRING`.
  \
  \ 2015-04-03:
  \
  \ Change: `CHAR` and `[CHAR]` are moved to the main file of
  \ the library. 
  \
  \ 2015-04-14:
  \
  \ New: `CMOVE>`, `MOVE`.


2 8 THRU 

( CMOVE> )

CREATE CMOVE>  ( ca1 ca2 u -- )  \ Forth-94

  \ Adapted from Lennart Benschop's Spectrum Forth-83.

  HEX
  D9 C,         \ exx
  C1 C,         \ pop bc
  D1 C,         \ pop de
  E1 C,         \ pop hl
  79 C,         \ ld a,c
  B0 C,         \ or b
  28 C, 8 C,    \ jr z,end

( CMOVE> MOVE )

  09 C,         \ add hl,bc
  2B C,         \ dec hl
  EB C,         \ ex de,hl
  09 C,         \ add hl,bc
  2B C,         \ dec hl
  EB C,         \ ex de,hl
  ED C, B8 C,   \ lddr
  \ end:
  D9 C,         \ exx
  C3 C, NEXT ,  \ jp NEXT
  SMUDGE DECIMAL

: MOVE  ( a1 a2 u -- )  \ Forth-94
 \ Note: Copied from Phil Burk's pForth (V19).
  >R 2DUP - 0< IF  R> CMOVE>  ELSE  R> CMOVE  THEN  ;

( Strings )

: PARSE-TEXT  ( c "ccc<c>" -- ca len )  TEXT PAD COUNT  ;
: PARSE-NAME  ( "name" -- ca len )  BL PARSE-TEXT  ;

: SLIT  ( -- ca len ) R COUNT DUP 1+ R> + >R  ;
: S,  ( ca len -- ) SWAP HERE ROT CMOVE 1+ ALLOT  ;
: SLITERAL  ( ca len -- ) COMPILE SLIT S,  ; IMMEDIATE

: PLACE  ( ca1 len1 ca2 )  2DUP C! 1+ SWAP MOVE  ;
: +PLACE  ( ca1 len1 ca2 )
  2DUP C@ + OVER C!  DUP C@ 1+ + SWAP MOVE  ;

: /STRING  ( ca1 len1 n -- ca2 len2 ) 
  DUP >R - SWAP R> + SWAP  ;

( S" S' )

  \ Reference from Don Thomasson's _Advanced Spectrum Forth_:

  \ :  (.")
  \   R COUNT DUP 1+ R> + >R TYPE  ;
  \ : ."
  \   [ 34 ] LITERAL STATE @
  \   IF COMPILE (.") WORD HERE C@ 1+ ALLOT
  \   ELSE WORD HERE COUNT TYPE  ; IMMEDIATE

: (S) ( Compilation: c "ccc<c>" -- ) ( Run-time:  -- ca len )
  STATE @
  IF    COMPILE SLIT WORD HERE C@ 1+ ALLOT
  ELSE  PARSE-TEXT  THEN  ;

: S"  ( Compilation: "ccc<">" -- ) ( Run-time:  -- ca len )
  [CHAR] " (S)  ; IMMEDIATE

: S'  ( Compilation: "ccc<'>" -- ) ( Run-time:  -- ca len )
  [CHAR] ' (S)  ; IMMEDIATE

( LENGTHS STR= )

: LENGTHS  ( ca1 len1 ca2 len2 -- ca1 len1 ca2 len2 len1 len2 )
  2 PICK OVER  ;

: STR=  ( ca1 len1 ca2 len2 -- f )
  2 PICK OVER -  \ different lenghts?
  IF    2DROP 2DROP FALSE EXIT
  ELSE  DROP [ CONTEXT @ EDITOR ] -TEXT [ CONTEXT ! ] 0= 0=
  THEN  ;

( Circular string buffer)

\ XXX TODO make it configurable, with deferred words
\ and a word to make the buffer.

512 CONSTANT /CSB  \ buffer size

/CSB VARIABLE CSB-UNUSED         \ unused buffer space
HERE  /CSB ALLOT  CONSTANT CSB0  \ bottom address

\ XXX TODO -- rewrite, make it faster:

: ?CSB  ( len -- )
  \ Make sure there's room for the given characters.
  DUP CSB-UNUSED @ > IF  /CSB CSB-UNUSED !  THEN
  MINUS CSB-UNUSED +!  ;

: STRING-ALLOCATE  ( len -- ca )
  ?CSB CSB0 CSB-UNUSED @ +  ;

  \ XXX TODO use `2>R` and `2R>` when available:
: SAVE-STRING  ( ca1 len1 -- ca2 len1 )
  DUP STRING-ALLOCATE SWAP  2DUP >R >R  MOVE  R> R>  ;

: SAVE-COUNTED-STRING  ( ca1 len1 -- ca2 )
  DUP 1+ STRING-ALLOCATE DUP >R PLACE R> ;

( SMOVE S+ )

: SMOVE  ( ca1 ca2 u -- )
  SWAP MOVE  ;

: S+  ( ca1 len1 ca2 len2 -- ca3 len3 )
  \ Append the string ca2 len2 to the end of string ca1 len1
  \ returning the resulting string ca2 len3.
  LENGTHS + >R          ( ca1 len2 ca2 len2 ) ( R: len3 )
  R STRING-ALLOCATE >R  ( R: len3 ca3 )
  2 PICK R +            ( ca1 len1 ca2 len2 len1+ca3 )
  SMOVE                 ( ca1 len1 )  \ 2nd string to buffer
  R SMOVE               \  1st string to buffer
  R> R>  ;

  \ vim: filetype=abersoftforth
