\ Extensions for Abersoft Forth By Marcos Cruz
\ (programandala.net) 1985,1986,1987,2015
\
  \ History
  \
  \ 1985, 1986, 1987:
  \
  \ `\`, `INVERT`, `>=`, `<=`, `<>`, `SGN` (from the Abersoft
  \ Forth manual), `NOR`, `NAND`, `NXOR`, `DEPTH`, `PICK`,
  \ `DRAWL`, `RDRAW`, `RDRAWL`.
  \
  \ 2015-03:
  \
  \ `CHAR`, `[CHAR]`, `PARSE-TEXT`, `PARSE-NAME`, `SLIT`, `S,`,
  \ `SLITERAL`, `.(`, `(S)`, `S"`, `S'`, `TLOAD`, `RUNT`,
  \ `BOUNDS`, `NIP`, `[DEFINED]`, `BYE`, `UDG!`, `AKEY`,
  \ `THRU`, `+LOAD` (after Gforth), `+THRU` (after Gforth),
  \ `RDROP`, `R@`, `RDEPTH`, `SGN`, `(after`, `Gforth)`,
  \ `RECURSE`, `ROLL` (after Gforth), `XY>ATTRA`.

( Backslash, files)

CR ." Loading extensions" CR

: \  ( "ccc<newline>" -- )
  IN @ DUP C/L > IF  B/BUF SWAP MOD  ELSE   C/L SWAP -  THEN
  IN +!  ; IMMEDIATE

: THRU  ( n1 n2 -- )  1+ SWAP DO  I LOAD  LOOP  ;
: +LOAD  ( n -- )  BLK @ LOAD  ;
: +THRU  ( n1 n2 -- )  1+ SWAP DO  I +LOAD  LOOP  ;
: TLOAD  ( n -- )  INIT-DISC LOADT LOAD  ;

  \ `RUNT` loads the next RAM-disc file from tape and then
  \ interprets its first block.  This word makes it possible to
  \ chain several RAM-disc files from tape, allowing the
  \ automatic compilation of sources larger than 10 blocks.
  \
  \ `QUIT` is needed at the end of `RUNT` because otherwise the
  \ `LOAD` that loaded the block of `RUNT` would continue to
  \ interpret after `RUNT`, but the contents of the block would
  \ had already been changed by `TLOAD`.

: RUNT  ( -- )  1 TLOAD QUIT  ;
 
 \ XXX OLD -- alternatives that don't work:
 \ : RUNT  ( -- )  1 TLOAD 0 BLK ! RP! ;
 \ : RUNT  ( -- )  1 TLOAD 0 BLK !  ;
 \ : RUNT  ( -- )  1 TLOAD RDROP  ;
 \ : RUNT  ( -- )  1 TLOAD [COMPILE] ;S  ;
 \ : RUNT  ( -- )  1 TLOAD R> RDROP RDROP >R ;

2 10 THRU

( Strings)

: CHAR  ( "name" -- c )  BL WORD HERE 1+ C@  ;
: [CHAR]  ( "name" -- c ) CHAR [COMPILE] LITERAL  ; IMMEDIATE
: PARSE-TEXT  ( c "ccc<c>" -- ca len )  TEXT PAD COUNT  ;
: PARSE-NAME  ( "name" -- ca len )  BL PARSE-TEXT  ;
: SLIT  ( -- ca len ) R COUNT DUP 1+ R> + >R  ;
: S,  ( ca len -- ) SWAP HERE ROT CMOVE 1+ ALLOT  ;
: SLITERAL  ( ca len -- ) COMPILE SLIT S,  ; IMMEDIATE
: .(  ( "ccc<paren>" -- ) [CHAR] ) PARSE-TEXT TYPE  ; IMMEDIATE

( Strings: S" S' )

  \ Copied from "Advanced Spectrum Forth",
  \ for reference:
  \ :  (.")
  \   R COUNT DUP 1+ R> + >R TYPE  ;
  \ : ."
  \   [ 34 ] LITERAL STATE @
  \   IF COMPILE (.") WORD HERE C@ 1+ ALLOT
  \   ELSE WORD HERE COUNT TYPE  ; IMMEDIATE

: (S) ( Compilation: c "ccc<c>" -- ) ( Run-time:  -- ca len )
  STATE @
  IF    COMPILE SLIT WORD HERE C@ 1+ ALLOT
  ELSE  PARSE-TEXT  THEN  ;

: S"  ( Compilation: "ccc<">" -- ) ( Run-time:  -- ca len )
  [CHAR] " (S)  ; IMMEDIATE

: S'  ( Compilation: "ccc<'>" -- ) ( Run-time:  -- ca len )
  [CHAR] ' (S)  ; IMMEDIATE

( Operators) 

  \ XXX TODO -- rewrite in assembler.

: INVERT  ( n1 -- n2 )  -1 XOR  ;
: BOUNDS  ( a1 len -- a2 a1 )  OVER + SWAP  ;
: >=  ( n1 n2 -- f ) 2DUP > ROT ROT SWAP = OR  ;
: <=  ( n1 n2 -- f ) 2DUP < ROT ROT SWAP = OR  ;
: <>  ( n1 n2 -- f ) = NOT  ;

  \ From the Abersoft Forth manual:
  \ : SGN  ( n1 -- n2 ) 1 +-  ;
  \ A better alternative, after Gforth:
: SGN  ( n1 -- -1|0|1 ) DUP IF  0< 2 * 1+  THEN  ;

( System)

2 CONSTANT CELL
: CELL+  ( n1 -- n2 )  2+  ;
: CELLS ( n1 -- n2 )  CELL *  ;
: NEXT  ( -- )  COMPILE [COMPILE] ;S  ; IMMEDIATE
: BYE  ( -- )  MON  ;

\ Actually rename `MON` to `BYE`:
\  ' MON NFA 1+
\  CHAR B OVER C!  CHAR Y OVER 1+ C!  CHAR E 128 + SWAP 2+ C!

: RECURSE  ( -- )  LATEST PFA CFA ,  ; IMMEDIATE

( Stack)

: DEPTH  ( -- u ) SP@ S0 @ - -2 /  ;
: PICK  ( u -- x ) 2 * 2 + SP@ + @  ;
: RDEPTH  ( -- u ) RP@ R0 @ - -2 /  ;
: RDROP  ( -- ) ( R: x -- )  NEXT  ;
: R@ ( -- x ) ( R: x -- x )  R ;

  \ XXX TODO -- finish
\ : ROLL  ( u -- )
\ 2 * 4 + DUP SP@ + DUP @ ROT 1 - DUP 2 + ROT 2 - CMOVE DROP  ;
  \ Gforth's recursive version:
\ : ROLL  ( u -- )
\   DUP 0<= IF  DROP  ELSE  SWAP >R 1- ROLL R> SWAP THEN  ;
 : ROLL  ( u -- )
   DUP 1 < IF  DROP  ELSE  SWAP >R 1 - RECURSE R> SWAP THEN  ;

: NIP  ( n1 n2 -- n2 ) SWAP DROP  ;

( Keyboard)

: AKEY  ( -- c )
  \ Wait for a key press and return its code.
  \ This is an alternative to 'KEY', because 'KEY'
  \ always shows the flashing cursor, even if the
  \ current attributes are changed.
  BEGIN  INKEY DUP 255 =  WHILE  DROP  REPEAT  ;

( Graphics)

 : DRAWL  ( x1 y1 x2 y2 -- )
  \ Draw a line from x1 y1 to x2 y2
  2SWAP PLOT DRAW  ;

  \ ZX Spectrum system variables:
23677 CONSTANT COORDS
COORDS CONSTANT X-COORD  COORDS 1+ CONSTANT Y-COORD

: RDRAW  ( inc-x inc-y -- )
  \ Draw a line from to the current plot position
  Y-COORD C@ + SWAP X-COORD C@ + SWAP DRAW  ;

: RDRAWL  ( x y inc-x inc-y -- )
  \ Draw a line from x1 y1
  2SWAP PLOT RDRAW  ;

: UDG!  ( b0..b7 c -- )
  \ Store the given 8 bytes into the c UDG char
  \ b0 = first (top) scan
  \ b7 = last (bottom) scan
  \ c = 144..164
  144 - 8 * UDG + 1 - DUP 8 + DO  I C!  -1 +LOOP  ;

22528 CONSTANT ATTRIBUTES
: XY>ATTRA  ( x y -- a )
  \ Convert a pixel coordinate to its attribute address.
  175 SWAP - 8 / 32 *  SWAP 8 /  + ATTRIBUTES +  ;

( Interpreter directives)

: [DEFINED]  ( "name" -- f )
  -FIND DUP IF NIP NIP THEN  ; IMMEDIATE


  \ vim: filetype=abersoftforth
