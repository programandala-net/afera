\ extend.fsb
\ Main extensions for ZX Spectrum Abersoft Forth

\ Copyright (C) 1985-1987,2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)

  \ -----------------------------------------------------------
  \ History of this file
  
  \ 1985, 1986, 1987:
  \
  \ `\`, `INVERT`, `>=`, `<=`, `<>`, `SGN` (from the Abersoft
  \ Forth manual), `NOR`, `NAND`, `NXOR`, `DEPTH`, `PICK`,
  \ `DRAWL`, `RDRAW`, `RDRAWL`.
  \
  \ 2015-03:
  \
  \ `CHAR`, `[CHAR]`, `PARSE-TEXT`, `PARSE-NAME`, `SLIT`, `S,`,
  \ `SLITERAL`, `.(`, `(S)`, `S"`, `S'`, `TLOAD`, `RUNT`,
  \ `BOUNDS`, `NIP`, `[DEFINED]`, `BYE`, `UDG!`, `AKEY`,
  \ `THRU`, `+LOAD` (after Gforth), `+THRU` (after Gforth),
  \ `RDROP`, `R@`, `RDEPTH`, `SGN`, `(after`, `Gforth)`,
  \ `RECURSE`, `ROLL` (after Gforth), `XY>ATTRA`, `[DEFINED]`.
  \
  \ 2015-03-28:
  \
  \ The graphics and strings extensions are moved to their own
  \ files. New: `[UNDEFINED]`. Fixes of Abersoft Forth's bugs:
  \ the RAM disk length and `EXIT`. Fix: `RDROP` was wrong.
  \ New: `/INIT-DISC`, `TUCK`.
  \
  \ 2015-03-29:
  \
  \ `TRUE`, `FALSE`, `ON`, `OFF`, `-ROT`, `?EXIT` (after
  \ Gforth), `ALIAS` (for code words only), `HERE:` (Afera
  \ specific), `BUFFER:` (after Forth-2012). The renamings 
  \ are moved to an own file.

  \ -----------------------------------------------------------

( Line comments, booleans, bug fixes)

CR ." Loading extensions" CR

  \ ............................................
  \ Line comment

: \  ( "ccc<newline>" -- )
  IN @ DUP C/L > IF  B/BUF SWAP MOD  ELSE   C/L SWAP -  THEN
  IN +!  ; IMMEDIATE

  \ ............................................
  \ Booleans

       0 CONSTANT FALSE
FALSE 0= CONSTANT TRUE

: ON   ( a -- )  TRUE  SWAP !  ;
: OFF  ( a -- )  FALSE SWAP !  ;

-->

( Bug fixes)

  \ ............................................
  \ Bugs found in Abersoft Forth
  \ during the development of Afera

  \ The length of the RAM disk is 11264 (0x2C00),
  \ not 11263 (0x2BFF):

11264 CONSTANT /RAM-DISC      \ length of the RAM disc
/RAM-DISC 30182 11 + !        \ patch the load tape header
/RAM-DISC ' INIT-DISC 6 + !   \ patch `INIT-DISC`

 \ `EXIT` must do `R> DROP`, not `>R DROP`:

 ' R> CFA ' EXIT !

-->

( Blocks)

  \ XXX FIXME `+LOAD` fails: `BLK+` is bigger than expected, at
  \ least after using `RUNT`

: THRU  ( n1 n2 -- )  1+ SWAP DO  I LOAD  LOOP  ;
: +LOAD  ( n -- )  BLK @ + LOAD  ;
: +THRU  ( n1 n2 -- )  1+ SWAP DO  I +LOAD  LOOP  ;
: TLOAD  ( n -- )  EMPTY-BUFFERS INIT-DISC LOADT LOAD  ;

  \ `RUNT` loads the next RAM disk file from tape and then
  \ interprets its first block.  This word makes it possible to
  \ chain several RAM disk files from tape, allowing the
  \ automatic compilation of sources larger than 10 blocks.
  \
  \ `QUIT` is needed at the end of `RUNT` because otherwise the
  \ `LOAD` that loaded the block of `RUNT` would continue to
  \ interpret after `RUNT`, but the contents of the block would
  \ had already been changed by `TLOAD`.

: RUNT  ( -- )  1 TLOAD ." ok" QUIT  ;

: /INIT-DISC  ( n -- )
  \ Blank the init disc from the given block number.
  \ XXX TODO use `/STRING`.
  1024 * DUP >R /RAM-DISC SWAP - LO R> + SWAP BLANKS  ;

4 10 THRU

( Operators) 

  \ XXX TODO -- rewrite in assembler.

: INVERT  ( n1 -- n2 )  -1 XOR  ;
: NEGATE  ( n1 -- n2 )  -1 *  ;
: BOUNDS  ( a1 len -- a2 a1 )  OVER + SWAP  ;
: >=  ( n1 n2 -- f ) 2DUP > ROT ROT SWAP = OR  ;
: <=  ( n1 n2 -- f ) 2DUP < ROT ROT SWAP = OR  ;
: <>  ( n1 n2 -- f ) = 0=  ;  \ `-` is faster
: SGN  ( n1 -- -1|0|1 ) DUP IF  0< 2 * 1+  THEN  ;

( System)


: ALIAS  ( pfa "name" -- )
  \ Create the word "name" as an alias of the *code* word
  \ whose pfa is given.
  \ NOTE: This works only for code words.
  \ XXX TODO make it work with any kind of word.
  [COMPILE] : [COMPILE] ;  LATEST PFA CFA !  ;

  \ XXX TODO Improved alternative:
: ALIAS  ( pfa "name" -- )
  \ Create the word "name" as an alias of the *code* word
  \ whose pfa is given.
  DUP DUP CFA @ =  \ code word?
  IF    [COMPILE] : [COMPILE] ;  LATEST PFA CFA !
  \ XXX FIXME :
  ELSE  CREATE SMUDGE (;CODE)
        195 C, CFA ,  \ jp cfa
        [COMPILE] ;
  THEN ;

2 CONSTANT CELL
: CELL+  ( n1 -- n2 )  2+  ;
: CELLS ( n1 -- n2 )  CELL *  ;

: RECURSE  ( -- )  LATEST PFA CFA ,  ; IMMEDIATE

  \ XXX TODO
 \ From vForth, but can't work:
 \ : :NONAME HERE DUP CELL+ , ;

( Stack)

: DEPTH  ( -- u ) SP@ S0 @ - -2 /  ;
: PICK  ( u -- x ) 2 * 2 + SP@ + @  ;
: RDEPTH  ( -- u ) RP@ R0 @ - -2 /  ;
: RDROP  ( -- ) ( R: x -- )  R> DROP  ;
: R@  ( -- x ) ( R: x -- x )  R  ;
: -ROT  ( x1 x2 x3 -- x3 x1 x2 )  ROT ROT  ;
  
  \ XXX TODO -- `2>R` and `2R>`

  \ XXX TODO -- finish
\ : ROLL  ( u -- )
\ 2 * 4 + DUP SP@ + DUP @ ROT 1 - DUP 2 + ROT 2 - CMOVE DROP  ;
  \ Gforth's recursive version:
\ : ROLL  ( u -- )
\   DUP 0<= IF  DROP  ELSE  SWAP >R 1- ROLL R> SWAP THEN  ;
 : ROLL  ( u -- )
   DUP 1 < IF  DROP  ELSE  SWAP >R 1 - RECURSE R> SWAP THEN  ;

: NIP  ( n1 n2 -- n2 ) SWAP DROP  ;
: TUCK  ( n1 n2 -- n2 n1 n2 )  SWAP OVER ;

( Keyboard)

: AKEY  ( -- c )
  \ Wait for a key press and return its code.
  \ This is an alternative to 'KEY', because 'KEY'
  \ always shows the flashing cursor, even if the
  \ current attributes are changed.
  BEGIN  INKEY DUP 255 =  WHILE  DROP  REPEAT  ;

( Control structures)

: ?EXIT  ( f -- )
  [COMPILE] IF  COMPILE EXIT  [COMPILE] THEN  ; IMMEDIATE

( Data structures)

: HERE:  ( "name" -- )
  \ Create a word "name" that will return its pfa, that will be
  \ empty (no bytes allocated during the definition).  This is
  \ syntactic sugar for a table definition whose contents will
  \ be compiled on the fly.
  0 VARIABLE  CELL NEGATE ALLOT  ;

: BUFFER:  ( u "name" -- )
  \ Create a word "name" and allocate u bytes in its pfa.
  \ "name" will return its pfa.
  HERE: ALLOT  ;

  \ vim: filetype=abersoftforth
