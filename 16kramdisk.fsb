\ 16kramdisk.fsb
\ 16-KiB RAM-disk for ZX Spectrum Abersoft Forth

\ Copyright (C) 2015 Marcos Cruz (programandala.net)

\ This file is part of
\ Afera (Abersoft Forth Extensions, Resources and Addons)
\ http://programandala.net/en.program.afera.html

  \ -----------------------------------------------------------
  \ Description

  \ Abersoft Forth uses an 11-Kib RAM-disk at the top of the
  \ memory map. This module patches the system in order to use
  \ a 16-KiB memory bank instead (ZX Spectrum 128K or later
  \ only), thus freeing those 11 KiB for the dictionary space.

  \ -----------------------------------------------------------
  \ Requirements

  \ <lowersys.fsb>

  \ -----------------------------------------------------------
  \ History

  \ 2015-05-11: Start.
  \
  \ 2015-05-12: Fix: the second check was missing in
  \ `DISC-BLOCK`, what caused `LIST` could be used with screen
  \ numbers greater than 16.  Fix: Also `(TAPE)` needed a
  \ patch, as the <tape.fsb> module does. First working
  \ version.

-->
.( 16-screen RAM-disk )

HEX
: 128K'SCR ( n --- a )
  \ n = RAM-disk screen (1..16)
  1-                      \ screen numbers start at 1
  DUP 10 U< 0= 6 ?ERROR   \ error if not in range 1..16
  \ 1 BANK /SCR * C000 +  ;  \ XXX OLD
  /SCR * C000 +  ;

  \ Patch `'SCR` to use the 128K version:
' 128K'SCR CFA ' 'SCR !

DECIMAL  -->

( 128K INIT-DISC )

HEX
4000 ' /DISC !  \ update the new length of the RAM-disk
  \ The RAM-disk bounds have to be updated later, when patching
  \ `R/W`.

: (INIT-DISC)  ( -- )
  \ Blank the RAM-disk, that must be already paged in.
  LO /DISC BLANKS ;

HERE
  \ Compile the patch for `INIT-DISC`:
  ' 1 CFA , ' BANK CFA ,
  ' (INIT-DISC) CFA ,
  ' 0 CFA , ' BANK CFA ,
  \ Move it:
DUP  ' INIT-DISC OVER HERE SWAP - CMOVE
DP ! \ restore the disctionary pointer

DECIMAL -->

( Tape )

HEX

  \ The load header (pointed by IX before calling the ROM
  \ routine) is at address 30182 (0x75E6).  Its 
  \ contents (after fixing the length bug) are:

  \ +00 : 3 (identifier of code file type)
  \ +01 : "DISC      " = 10-char filename, padded with spaces
  \ +11 : 11264 (0x2C00)  = length
  \ +13 : 53248 (0xD0FF)  = start address
  \ +15 : "  " (2 spaces) = not used for code files

  \ Patch the load header
  \ with the new length and start address:
  /DISC 75E6 0B + !
   C000 75E6 0D + !  \ C000 is the new `LO`, still unchanged

  \ Patch the tape words to use the new RAM-disk

: (LOADT)   ( 0 -- )  1 BANK (TAPE) 0 BANK  ;
: (SAVET)   ( 1 -- )  1 BANK (TAPE) 0 BANK  ;
: (VERIFY)  ( 2 -- )  1 BANK (TAPE) 0 BANK  ;

' (LOADT)  CFA ' LOADT  2+  !
' (SAVET)  CFA ' SAVET  4 + !
' (VERIFY) CFA ' VERIFY 2+  !

DECIMAL -->

( DISC-BLOCK )

  \ Patched `R/W`, decoded:
  \
  \ 7225 : R/W 
  \ 721F   >R 
  \ 7221   B/BUF 
  \ 7223   BUF*  \ patched
  \ 7225   LO 
  \ 7227   + 
  \ 7229   DUP 
  \ 722B   HI 
  \ 722D   > 
  \ 722F   LIT 6 
  \ 7233   ?ERROR 
  \ 7235   R> 
  \ 7237   0BRANCH 4  \ to 723D 
  \ 723B   SWAP 
  \ 723D   B/BUF 
  \ 723F   CMOVE 
  \ 7241   ;S

  \ : BUF*  ( n1 +n2 -- +n3 )

  \   \ Calculate the relative address +n3 of disk block n1 in the
  \   \ Forth RAM-disk. Give error #6 when the requested disk block
  \   \ n1 belongs to the first screen of the RAM-disk.  Finally
  \   \ update the result one screen below.

  \   \ n1 = number of sequential disk block
  \   \ +n2 = bytes per block buffer, returned by `B/BUF`
  \   \ +n3 = offset in the RAM-disk (from 0 to `HI B/BUF -`)

  \   * DUP /SCR U< 06 ?ERROR  /SCR -  ;

  \ : R/W  ( a n f -- )
  \   >R 
  \   B/BUF BUF*  \ patched
  \   LO + 
  \   DUP HI > 6 ?ERROR
  \   R> IF  SWAP   THEN
  \   B/BUF CMOVE ;

: DISC-BLOCK  ( n -- a )

  \ Calculate the address of disk block n1 in the Forth RAM
  \ disk. Give error #6 when the requested disk block n1
  \ belongs to the first screen of the RAM-disk.  Finally
  \ update the result one screen below.

  \ n = number of sequential disk block
  \ a = address in the RAM-disk

  B/BUF * DUP /SCR U< 6 ?ERROR
  LO + /SCR - DUP HI > 6 ?ERROR  ;


: (R/W)  ( a1 a2 f -- )
  \ Read to or write from the new RAM-disk.
  \ a1 = buffer address
  \ a2 = address in the RAM-disk
  \ f =  0 for writing; 1 for reading
  IF  SWAP  THEN  B/BUF 1 BANK CMOVE 0 BANK  ;

-->

( Patch )

: PATCH-R/W  ( -- )

  \ Patch `R/W` to use the new RAM-disk.

  \ Update the RAM-disk bounds, when paged in:
  [ HEX ]  C000 ' LO !
  LO /DISC + 1- ' HI !

  \ Patch `(TAPE)`
  \ with the new default file start address:
  LO 7619 !

  \ Make sure the buffers are empty before patching `R/W`:
  EMPTY-BUFFERS

  \ Patch `R/W`:
  ' >R          CFA ' R/W !
  ' DISC-BLOCK  CFA ' R/W 2+ !
  ' R>          CFA ' R/W 4 + !
  ' (R/W)       CFA ' R/W 6 + !
  ' ;S          CFA ' R/W 8 + !

  \ The word `FREE` returns the free dictionary space.  Its
  \ original definition, according to the original memory map,
  \ is:
  \
  \   : FREE  ( -- n )  SP@ HERE -  ;
  \ 
  \ After been patched by the <lowersys.fsb> module, its
  \ definition is:
  \
  \   : FREE  ( -- n )  LO HERE -  ;
  \
  \ It has to be modified once more because now all RAM is
  \ free, so '0' must be used instead of 'LO':
  ' 0 CFA ' FREE !

  \ Make this word to forget itself:
  [ LATEST ] LITERAL DUP DP ! PFA LFA @ CURRENT @ !

  \ Done and quit:
  CR ." 128K version of R/W installed." DECIMAL QUIT

  ;  PATCH-R/W

( 48K R/W ) \ XXX TMP

: R/W  ( a n f -- )
  \ 48K version of R/W
  >R
  DISC-BLOCK
  R> IF  SWAP   THEN  B/BUF CMOVE  ;

  \ vim: filetype=abersoftforth
